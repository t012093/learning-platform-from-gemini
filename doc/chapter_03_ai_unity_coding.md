# 第3章｜AIにUnityコードを書かせる

## 3-1. Unity向けプロンプト設計

### 悪い指示と良い指示
*   ❌ **悪い指示**: 「ゲームのコード書いて」「動くようにして」
    *   曖昧すぎて、AIは適当な解釈をします。
*   ⭕ **良い指示**: 「Unity C#で、矢印キーで動くプレイヤーのコントローラーを作ってください。Rigidbodyを使用し、物理演算で移動させたいです。ジャンプ機能は不要です。」
    *   **コンテキスト（Unity C#）**、**やりたいこと（矢印移動）**、**手段（Rigidbody）**、**制約（ジャンプ不要）**が明確です。

### 制約・拡張予定の書き方
*   「将来的にスマホ対応したいので、入力判定は関数に切り出しておいて」
*   「パブリック変数は使わず、[SerializeField]を使って」
*   このように**設計上のこだわり**を最初に伝えると、手戻りが減ります。

## 3-2. 実践：AIと最小ゲーム

### プレイヤー操作
*   まずは「動く箱」を作ります。
*   プロンプト例: `PlayerController.csを作成してください。WASDキーで前後左右に移動します。移動速度はInspectorで調整可能にしてください。`

### ゴール判定
*   「触れたらクリア」の仕組み。
*   プロンプト例: `Goal.csを作成してください。タグが"Player"のオブジェクトが接触(OnTriggerEnter)したら、コンソールに"Goal!"と表示してください。`

### UI表示
*   クリア文字の表示。
*   プロンプト例: `GameManager.csを作成してください。ゴール時にUIのTextコンポーネントに"GAME CLEAR"と表示する処理を追加したいです。`

## 3-3. AIコードあるある事故

### Update地獄
*   Update関数の中で `Find` や `GetComponent` などの重い処理を書いてしまうこと。
*   対処法: AIに「重い処理はCacheしてください（Startで変数に入れておく）」と指示する。

### Find多用
*   `GameObject.Find("Name")` は便利ですが、名前が変わると動かなくなるし、処理も重いです。
*   対処法: 「Inspectorで参照を設定するように実装して」と指示する。

### 巨大スクリプト
*   1つのファイルに移動も攻撃もUIも全部書いてしまう。
*   対処法: 「移動処理はMoveController、攻撃はAttackManagerに分けて」と分割を指示する。

👉 **「動いた＝完成ではない」**
*   動いた後にコードをさらっと見て、上記の「事故」がないかチェックするのが人間の仕事です。
